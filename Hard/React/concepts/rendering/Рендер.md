>[!info] Рендер в Реакт это вызов компонента (а компонент это функция)
>1) Реакт вызывает компонент еще раз
>2) Компонент возвращает новый снимок JSX
>3) Реакт обновляет экран что бы он совпадал с вернувшимся снимком JSX

## Шаг 1: Триггер рендера

Причины рендера компонента:

1. Это **начальный рендер.**
2. У компонента (или его родителей) **обновился стейт.**

Начальный рендер - это вызов `createRoot()`

## Шаг 2. React отображает ваши компоненты

После запуска рендеринга React вызывает ваши компоненты, чтобы выяснить, что отображать на экране. **«Рендеринг» — это вызов ваших компонентов в React.**

- **При первоначальном рендеринге** React вызовет корневой компонент.
- **Для последующих рендерингов** React будет вызывать компонент функции, обновление состояния которого инициировало рендеринг.

Этот процесс является рекурсивным: если обновленный компонент возвращает какой-то другой компонент, React следующим отрисовывает _этот_ компонент, а если этот компонент также что-то возвращает, он затем визуализирует _этот_ компонент и так далее. Процесс будет продолжаться до тех пор, пока не останется вложенных компонентов и React точно не будет знать, что должно отображаться на экране.

## Шаг 3. React фиксирует изменения в DOM.

После рендеринга (вызова) ваших компонентов React изменит DOM.

- **Для первоначального рендеринга** React будет использовать [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild)DOM API, чтобы разместить на экране все созданные им узлы DOM.
- **Для повторного рендеринга** React применит минимально необходимые операции (вычисленные во время рендеринга!), чтобы DOM соответствовал последнему результату рендеринга.

**React меняет узлы DOM только в том случае, если между рендерами есть разница.** Например, вот компонент, который каждую секунду повторно отображает различные реквизиты, передаваемые от его родителя. Обратите внимание, как вы можете добавить некоторый текст в `<input>`, обновляя его `value`, но текст не исчезает при повторной визуализации компонента:

>[!info] Реакт будет ждать выполнения всех `setState` перед тем как сделать рендер, что бы исключить лишние рендеры

## Когда происходит ререндер

>[!info] Изменение стейта

![[render-reason-state.png]]

>[!info] Ререндер родителя

![[render-reason-parent.png]]

>[!info] Изменение контекста

![[render-reason-context.png]]

>[!info] Изменение хука

![[render-reason-hook.png]]

## Предотвращение ререндеринга с помощью композиции

Антипаттерн: создание компонентов в функции рендеринга

```jsx
const Component = () => {
const [state, setState] = useState(1);
const onClick = () => {
	setState(state + 1);
};

const VerySlowComponent = () => {
	console.log("Very slow component re-renders");
	useEffect(() => {
	console.log("Very slow component re-mounts");
}, []);

return <div>Very slow component</div>;
};

return (
	<>
		<button onClick={onClick}>click here</button>
		<VerySlowComponent />
	</>
	);
};
```

>[!danger] Создание компонентов внутри функции рендеринга другого компонента является антипаттерном, который может очень негативно влиять на производительность. 
>`React` будет повторно монтировать (remount), т. е. уничтожать и создавать с нуля такой компонент при каждом рендеринге, что будет существенно замедлять обычный рендеринг. 
>Это может привести к таким багам, как:
>- «вспышки» (flashes) разного контента в процессе рендеринга;
>- сброс состояния компонента при каждом рендеринге;
>- запуск `useEffect` без зависимостей при каждом рендеринге;
>- потеря фокуса, если компонент находился в этом состоянии и т. д.

### Паттерн: перемещение состояния вниз

![[state-down.png]]
### Паттерн: передача потомков в виде пропов

![[children-as-prop.png]]

### Паттерн: передача компонентов в виде пропов

![[component-as-prop.png]]

## Предотвращение ререндеринга с помощью `React.memo`

![[react-memo.png]]

### `React.memo`: компонент с пропами

![[react-memo-props.png]]

### `React.memo`: компоненты, передаваемыми в виде пропов, или потомки

![[react-memo-children.png]]

## Повышение производительности ререндеринга с помощью хуков `useCallback` и `useMemo`

### Антипаттерн: ненужная мемоизация пропов с помощью `useCallback/useMemo`

![[react-memo-antipattern.png]]

### Обязательное применение `useMemo/useCallback`

Если дочерний компонент обернут в `React.memo`, все пропы, не являющиеся примитивами, должны быть предварительно мемоизированы.

![[react-memo-required.png]]![[react-memo-required-2.png]]

### Использование `useMemo` для «дорогих» вычислений

![[react-memo-expensive.png]]
## Повышение производительности ререндеринга списков

![[list.png]]

### Антипаттерн: произвольные значения пропа `key`

![[list-antipattern.png]]
## Предотвращение ререндеринга, вызываемого контекстом

### Мемоизация значения, передаваемого провайдеру

![[context-memoize.png]]
### Разделение данных и интерфейсов

![[context-separate.png]]
### Разделение данных на части

![[context-parts.png]]

### Селекторы контекста

![[context-selectors.png]]