`Мост` — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные
иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

## Структура

![img.png](Hard/OOP/Patterns/Structural/Bridge/img.png)

1. `Абстракция` содержит управляющую логику. Код абстракции делегирует реальную работу связанному объекту реализации.
2. `Реализация` задаёт общий интерфейс для всех реализаций.
   Все методы, которые здесь описаны, будут доступны из класса абстракции и его подклассов.

   Интерфейсы абстракции и реализации могут как совпадать, так и быть совершенно разными. Но обычно в реализации живут
   базовые операции, на которых строятся сложные операции абстракции.
3. `Конкретные реализации` содержат платформо-зависимый код.
4. `Расширенные абстракции` содержат различные вариации управляющей логики. Как и родитель, работает с реализациями
   только
   через общий интерфейс реализации.
5. `Клиент` работает только с объектами абстракции. Не счи тая начального связывания абстракции с одной из реализаций,
   клиентский код не имеет прямого доступа к объектам реализации.

## Применимость

**1.Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то
функциональности (например, если класс может работать с разными системами баз данных). **
:::note

Чем больше класс, тем тяжелее разобраться в его коде, и тем больше это затягивает разработку. Кроме того, изменения,
вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к внесению случайных ошибок в
код.

Мост позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код
независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

:::
**2. Когда класс нужно расширять в двух независимых плоскостях.**
:::note

Мост предлагает выделить одну из таких плоскостей в отдельную иерархию классов, храня ссылку на один из её объектов в
первоначальном классе.

:::
**3. Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.**
:::note

Мост позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс
абстракции.

:::

## Преимущества и недостатки

:::tip

* Позволяет строить платформо-независимые программы.
* Скрывает лишние или опасные детали реализации от клиентского кода.
* Реализует принцип открытости/закрытости

:::

:::danger

* Усложняет код программы из-за введения дополнительных классов.

:::

## Отношения с другими паттернами

* `Мост` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. `Адаптер` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
* `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. 
 
   Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
* `Абстрактная фабрика` может работать совместно с `Мостом`. 
 
  Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
* Паттерн `Строитель` может быть построен в виде `Моста`: директор будет играть роль абстракции, а строители — реализации.

## Пример

```ts
/**
 * Паттерн Мост
 *
 * Назначение: Разделяет один или несколько классов на две отдельные иерархии —
 * абстракцию и реализацию, позволяя изменять их независимо друг от друга.
 *
 *               A
 *            /     \                        A         N
 *          Aa      Ab        ===>        /     \     / \
 *         / \     /  \                 Aa(N) Ab(N)  1   2
 *       Aa1 Aa2  Ab1 Ab2
 */

/**
 * Абстракция устанавливает интерфейс для «управляющей» части двух иерархий
 * классов. Она содержит ссылку на объект из иерархии Реализации и делегирует
 * ему всю настоящую работу.
 */
class Abstraction {
    protected implementation: Implementation;

    constructor(implementation: Implementation) {
        this.implementation = implementation;
    }

    public operation(): string {
        const result = this.implementation.operationImplementation();
        return `Abstraction: Base operation with:\n${result}`;
    }
}

/**
 * Можно расширить Абстракцию без изменения классов Реализации.
 */
class ExtendedAbstraction extends Abstraction {
    public operation(): string {
        const result = this.implementation.operationImplementation();
        return `ExtendedAbstraction: Extended operation with:\n${result}`;
    }
}

/**
 * Реализация устанавливает интерфейс для всех классов реализации. Он не
 * должен соответствовать интерфейсу Абстракции. На практике оба интерфейса
 * могут быть совершенно разными. Как правило, интерфейс Реализации
 * предоставляет только примитивные операции, в то время как Абстракция
 * определяет операции более высокого уровня, основанные на этих примитивах.
 */
interface Implementation {
    operationImplementation(): string;
}

/**
 * Каждая Конкретная Реализация соответствует определённой платформе и
 * реализует интерфейс Реализации с использованием API этой платформы.
 */
class ConcreteImplementationA implements Implementation {
    public operationImplementation(): string {
        return 'ConcreteImplementationA: Here\'s the result on the platform A.';
    }
}

class ConcreteImplementationB implements Implementation {
    public operationImplementation(): string {
        return 'ConcreteImplementationB: Here\'s the result on the platform B.';
    }
}

/**
 * За исключением этапа инициализации, когда объект Абстракции связывается с
 * определённым объектом Реализации, клиентский код должен зависеть только от
 * класса Абстракции. Таким образом, клиентский код может поддерживать любую
 * комбинацию абстракции и реализации.
 */
function clientCode(abstraction: Abstraction) {
    // ..

    console.log(abstraction.operation());

    // ..
}

/**
 * Клиентский код должен работать с любой предварительно сконфигурированной
 * комбинацией абстракции и реализации.
 */
let implementation = new ConcreteImplementationA();
let abstraction = new Abstraction(implementation);
clientCode(abstraction);

console.log('');

implementation = new ConcreteImplementationB();
abstraction = new ExtendedAbstraction(implementation);
clientCode(abstraction);
```