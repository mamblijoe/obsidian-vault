`Одиночка` — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и
предоставляет к нему глобальную точку доступа.

## Структура

![img.png](Hard/OOP/Patterns/Creational/Singleton/img.png)

1. `Одиночка` определяет статический метод getInstance, который возвращает единственный экземпляр своего класса.

   Конструктор одиночки должен быть скрыт от клиентов. Вызов метода getInstance должен стать единственным способом
   получить объект этого класса.

## Применимость

**1. Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий
доступ к базе данных из разных частей программы).**
:::note

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт
объект, либо отдаёт существующий объект, если он уже был создан.

:::
**2. Когда вам хочется иметь больше контроля над глобальными переменными.**
:::note

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса,
поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв
код в одном месте (метод getInstance ).

:::

## Преимущества и недостатки

:::tip

* Гарантирует наличие единственного экземпляра класса.
* Предоставляет к нему глобальную точку доступа.
* Реализует отложенную инициализацию объекта-одиночки.

:::

:::danger

* Нарушает принцип единственной ответственности класса.
* Маскирует плохой дизайн.
* Проблемы мультипоточности.
* Требует постоянного создания Mock-объектов при юнит-тестировании.

:::

## Отношения с другими паттернами
* [`Фасад`](../../structural/Facade) можно сделать `Одиночкой`, так как обычно нужен только один объект-фасад.

* Паттерн [`Легковес`](../../structural/Flyweight) может напоминать `Одиночку`, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
  * В отличие от `Одиночки`, вы можете иметь множество объектов-легковесов.
  * Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
   
* [`Абстрактная фабрика`](../Abstract-factory), [`Строитель`](../Builder) и [`Прототип`](../Prototype) могут быть реализованы при помощи `Одиночки`.
## Пример

```ts
/**
 * Паттерн Одиночка
 *
 * Назначение: Гарантирует, что у класса есть только один экземпляр, и
 * предоставляет к нему глобальную точку доступа.
 */

/**
 * Класс Одиночка предоставляет метод getInstance, который позволяет
 * клиентам получить доступ к уникальному экземпляру одиночки.
 */
class Singleton {
    private static instance: Singleton;

    /**
     * Конструктор Одиночки всегда должен быть скрытым, чтобы предотвратить
     * создание объекта через оператор new.
     */
    private constructor() { }

    /**
     * Статический метод, управляющий доступом к экземпляру одиночки.
     *
     * Эта реализация позволяет вам расширять класс Одиночки, сохраняя повсюду
     * только один экземпляр каждого подкласса.
     */
    public static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }

        return Singleton.instance;
    }

    /**
     * Наконец, любой одиночка должен содержать некоторую бизнес-логику,
     * которая может быть выполнена на его экземпляре.
     */
    public someBusinessLogic() {
        // ...
    }
}

/**
 * Клиентский код.
 */
function clientCode() {
    const s1 = Singleton.getInstance();
    const s2 = Singleton.getInstance();

    if (s1 === s2) {
        console.log('Singleton works, both variables contain the same instance.');
    } else {
        console.log('Singleton failed, variables contain different instances.');
    }
}

clientCode();
```