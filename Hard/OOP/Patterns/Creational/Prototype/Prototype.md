`Прототип` — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их
реализации.

## Структура

![img.png](Hard/OOP/Patterns/Creational/Prototype/img.png)

1. `Интерфейс прототипов` описывает операции клонирования.

   В большинстве случаев — это единственный метод clone .

2. `Конкретный прототип` реализует операцию клонирования самого себя.

   Помимо банального копирования значений всех полей, здесь могут быть спрятаны различные сложности, о которых не нужно
   знать клиенту. Например, клонирование связанных объектов, распутывание рекурсивных зависимостей и прочее.
3. `Клиент` создаёт копию объекта, обращаясь к нему через общий интерфейс прототипов.

## Применимость

**1. Когда ваш код не должен зависеть от классов копируемых объектов.**
:::note

Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете
привязаться к их классам, даже если бы хотели, поскольку их конкретные классы неизвестны.

Паттерн прототип предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту не нужно зависеть от
всех классов копируемых объектов, а только от интерфейса клонирования.

:::

**2. Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы,
чтобы иметь возможность легко порождать объекты с определённой конфигурацией.**
:::note

Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных
конфигураций объектов.

Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых
уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её
сложность.

:::

## Преимущества и недостатки

:::tip

* Позволяет клонировать объекты, не привязываясь к их конкретным классам.
* Меньше повторяющегося кода инициализации объектов.
* Ускоряет создание объектов.
* Альтернатива созданию подклассов для конструирования сложных объектов.

:::

:::danger

* Сложно клонировать составные объекты, имеющие ссылки на другие объекты.

:::

## Отношения с другими паттернами

* Многие архитектуры начинаются с применения [`Фабричного метода`](../Factory-method) (более простого и расширяемого
  через подклассы) и эволюционируют в сторону [`Абстрактной фабрики`](../Abstract-factory), `Прототипа`
  или [`Строителя`](../Builder) (более гибких, но и более сложных).
* Классы [`Абстрактной фабрики`](../Abstract-factory) чаще всего реализуются с
  помощью [`Фабричного метода`](../Factory-method), хотя они могут быть построены и на основе `Прототипа`.
* Если [`Команду`](../../behavioral/Command) нужно копировать перед вставкой в историю выполненных команд, вам может
  помочь `Прототип`.
* Архитектура, построенная на [`Компоновщиках`](../../structural/Composite)
  и [`Декораторах`](../../structural/Decorator), часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет
  клонировать сложные структуры объектов, а не собирать их заново.
* `Прототип` не опирается на наследование, но ему нужна сложная операция
  инициализации. [`Фабричный метод`](../Factory-method), наоборот, построен на наследовании, но не требует сложной
  инициализации.
* [`Снимок`](../../behavioral/Memento) иногда можно заменить `Прототипом`, если объект, состояние которого требуется
  сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.
* [`Абстрактная фабрика`](../Abstract-factory), [`Строитель`](../Builder) и `Прототип` могут быть реализованы при
  помощи [`Одиночки`](../Singleton).

## Пример

```ts
/**
 * Паттерн Прототип
 *
 * Назначение: Позволяет копировать объекты, не вдаваясь в подробности их
 * реализации.
 */

/**
 * Пример класса, имеющего возможность клонирования. Мы посмотрим как
 * происходит клонирование значений полей разных типов.
 */
class Prototype {
    public primitive: any;
    public component: object;
    public circularReference: ComponentWithBackReference;

    public clone(): this {
        const clone = Object.create(this);

        clone.component = Object.create(this.component);

        // Клонирование объекта, который имеет вложенный объект с обратной
        // ссылкой, требует специального подхода. После завершения клонирования
        // вложенный объект должен указывать на клонированный объект, а не на
        // исходный объект. Для данного случая хорошо подойдёт оператор
        // расширения (spread).
        clone.circularReference = {
            ...this.circularReference,
            prototype: {...this},
        };

        return clone;
    }
}

class ComponentWithBackReference {
    public prototype;

    constructor(prototype: Prototype) {
        this.prototype = prototype;
    }
}

/**
 * Клиентский код.
 */
function clientCode() {
    const p1 = new Prototype();
    p1.primitive = 245;
    p1.component = new Date();
    p1.circularReference = new ComponentWithBackReference(p1);

    const p2 = p1.clone();
    if (p1.primitive === p2.primitive) {
        console.log('Primitive field values have been carried over to a clone. Yay!');
    } else {
        console.log('Primitive field values have not been copied. Booo!');
    }
    if (p1.component === p2.component) {
        console.log('Simple component has not been cloned. Booo!');
    } else {
        console.log('Simple component has been cloned. Yay!');
    }

    if (p1.circularReference === p2.circularReference) {
        console.log('Component with back reference has not been cloned. Booo!');
    } else {
        console.log('Component with back reference has been cloned. Yay!');
    }

    if (p1.circularReference.prototype === p2.circularReference.prototype) {
        console.log('Component with back reference is linked to original object. Booo!');
    } else {
        console.log('Component with back reference is linked to the clone. Yay!');
    }
}

clientCode();
```