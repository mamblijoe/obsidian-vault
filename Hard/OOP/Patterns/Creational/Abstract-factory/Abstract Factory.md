`Абстрактная фабрика` — это порождающий паттерн проектирования, который позволяет создавать семейства связанных
объектов, не привязываясь к конкретным классам создаваемых объектов.

## Структура

![img.png](Hard/OOP/Patterns/Creational/Abstract-factory/img.png)

1. `Абстрактные продукты` объявляют интерфейсы продуктов, которые связаны друг с другом по смыслу, но выполняют разные
   функции.
2. `Конкретные продукты` — большой набор классов, которые относятся к различным абстрактным продуктам (кресло/столик),
   но
   имеют одни и те же вариации (Викторианский/Модерн).
3. `Абстрактная фабрика` объявляет методы создания различных абстрактных продуктов (кресло/столик).
4. `Конкретные фабрики` относятся каждая к своей вариации продуктов (Викторианский/Модерн) и реализуют методы
   абстрактной
   фабрики, позволяя создавать все продукты определённой вариации.
5. Несмотря на то, что конкретные фабрики порождают конкретные продукты, сигнатуры их методов должны возвращать
   соответствующие абстрактные продукты. Это позволит клиентскому коду, использующему фабрику, не привязываться к
   конкретным классам продуктов. Клиент сможет работать с любыми вариациями продуктов через абстрактные интерфейсы.

## Применимость

**1. Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от
конкретных классов продуктов.
>[!tip] Решение
>
>Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при
этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее
определён.

**2. Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов
продуктов.**

>[!tip] Решение
В хорошей программе каждый класс отвечает только за одну вещь. Если класс имеет слишком много фабричных методов, они
способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию
классов, применив абстрактную фабрику.

## Преимущества и недостатки

>[!tip] Преимущества
>* Гарантирует сочетаемость создаваемых продуктов.
>* Избавляет клиентский код от привязки к конкретным классам продуктов.
>* Выделяет код производства продуктов в одно место, упрощая поддержку кода.
>* Упрощает добавление новых продуктов в программу.
>* Реализует принцип открытости/закрытости.

>[!danger] Недостатки
>* Усложняет код программы из-за введения множества дополнительных классов.
>* Требует наличия всех типов продуктов в каждой вариации.

## Отношения с другими паттернами

* Многие архитектуры начинаются с применения [[Factory Method]] (более простого и расширяемого через подклассы) и
  эволюционируют в сторону [[Abstract Factory]], [[Prototype]] или [[Builder]] (более гибких, но и более сложных).
* [[Builder]] концентрируется на построении сложных объектов шаг за шагом. [[Abstract Factory]] специализируется на
  создании семейств связанных продуктов. [[Builder]] возвращает продукт только после выполнения всех шагов, а [[Abstract Factory]] возвращает продукт сразу же.
* Классы [[Abstract Factory]] чаще всего реализуются с помощью [[Factory Method]], хотя они могут быть построены и на
  основе [[Prototype]].
* [[Abstract Factory]] может быть использована вместо [[Facade]] для того, чтобы скрыть платформо-зависимые классы.
* [[Abstract Factory]] может работать совместно с [[Bridge]].
  Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом
  случае фабрика будет определять типы создаваемых абстракций и реализаций.
* [[Abstract Factory]], [[Builder]] и [[Prototype]] могут быть реализованы при помощи [[Singleton]].

## Пример

```ts
/**
 * Паттерн Абстрактная Фабрика
 *
 * Назначение: Предоставляет интерфейс для создания семейств связанных или
 * зависимых объектов без привязки к их конкретным классам.
 */

/**
 * Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
 * различные абстрактные продукты. Эти продукты называются семейством и связаны
 * темой или концепцией высокого уровня. Продукты одного семейства обычно могут
 * взаимодействовать между собой. Семейство продуктов может иметь несколько
 * вариаций, но продукты одной вариации несовместимы с продуктами другой.
 */
interface AbstractFactory {
    createProductA(): AbstractProductA;
    createProductB(): AbstractProductB;
}

/**
 * Конкретная Фабрика производит семейство продуктов одной вариации. Фабрика
 * гарантирует совместимость полученных продуктов. Обратите внимание, что
 * сигнатуры методов Конкретной Фабрики возвращают абстрактный продукт, в то
 * время как внутри метода создается экземпляр конкретного продукта.
 */
class ConcreteFactory1 implements AbstractFactory {
    public createProductA(): AbstractProductA {
        return new ConcreteProductA1();
    }

    public createProductB(): AbstractProductB {
        return new ConcreteProductB1();
    }
}

/**
 * Каждая Конкретная Фабрика имеет соответствующую вариацию продукта.
 */
class ConcreteFactory2 implements AbstractFactory {
    public createProductA(): AbstractProductA {
        return new ConcreteProductA2();
    }

    public createProductB(): AbstractProductB {
        return new ConcreteProductB2();
    }
}

/**
 * Каждый отдельный продукт семейства продуктов должен иметь базовый
 * интерфейс. Все вариации продукта должны реализовывать этот интерфейс.
 */
interface AbstractProductA {
    usefulFunctionA(): string;
}

/**
 * Эти Конкретные Продукты создаются соответствующими Конкретными Фабриками.
 */
class ConcreteProductA1 implements AbstractProductA {
    public usefulFunctionA(): string {
        return 'The result of the product A1.';
    }
}

class ConcreteProductA2 implements AbstractProductA {
    public usefulFunctionA(): string {
        return 'The result of the product A2.';
    }
}

/**
 * Базовый интерфейс другого продукта. Все продукты могут взаимодействовать
 * друг с другом, но правильное взаимодействие возможно только между продуктами
 * одной и той же конкретной вариации.
 */
interface AbstractProductB {
    /**
     * Продукт B способен работать самостоятельно...
     */
    usefulFunctionB(): string;

    /**
     * Абстрактная Фабрика гарантирует, что все продукты, которые она создает,
     * имеют одинаковую вариацию и, следовательно, совместимы.
     */
    anotherUsefulFunctionB(collaborator: AbstractProductA): string;
}

/**
 * Эти Конкретные Продукты создаются соответствующими Конкретными Фабриками.
 */
class ConcreteProductB1 implements AbstractProductB {

    public usefulFunctionB(): string {
        return 'The result of the product B1.';
    }

    /**
     * Продукт B1 может корректно работать только с Продуктом A1. Тем не
     * менее, он принимает любой экземпляр Абстрактного Продукта А в качестве
     * аргумента.
     */
    public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
        const result = collaborator.usefulFunctionA();
        return `The result of the B1 collaborating with the (${result})`;
    }
}

class ConcreteProductB2 implements AbstractProductB {

    public usefulFunctionB(): string {
        return 'The result of the product B2.';
    }

    /**
     * Продукт B2 может корректно работать только с Продуктом A2. Тем не
     * менее, он принимает любой экземпляр Абстрактного Продукта А в качестве
     * аргумента.
     */
    public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
        const result = collaborator.usefulFunctionA();
        return `The result of the B2 collaborating with the (${result})`;
    }
}

/**
 * Клиентский код работает с фабриками и продуктами только через абстрактные
 * типы: Абстрактная Фабрика и Абстрактный Продукт. Это позволяет передавать
 * любой подкласс фабрики или продукта клиентскому коду, не нарушая его.
 */
function clientCode(factory: AbstractFactory) {
    const productA = factory.createProductA();
    const productB = factory.createProductB();

    console.log(productB.usefulFunctionB());
    console.log(productB.anotherUsefulFunctionB(productA));
}

/**
 * Клиентский код может работать с любым конкретным классом фабрики.
 */
console.log('Client: Testing client code with the first factory type...');
clientCode(new ConcreteFactory1());

console.log('');

console.log('Client: Testing the same client code with the second factory type...');
clientCode(new ConcreteFactory2());
```