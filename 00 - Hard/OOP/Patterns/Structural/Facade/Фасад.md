`Фасад` — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов,
библиотеке или фреймворку.

## Структура

![img.png](00%20-%20Hard/OOP/Patterns/Structural/Facade/img.png)

1. `Фасад` предоставляет быстрый доступ к определённой функциональности подсистемы. Он «знает», каким классам нужно
   переадресовать запрос, и какие данные для этого нужны.
2. `Дополнительный фасад` можно ввести, чтобы не «захламлять» единственный фасад разнородной функциональностью. Он может
   использоваться как клиентом, так и другими фасадами.
3. `Сложная подсистема` состоит из множества разнообразных классов. Для того, чтобы заставить их что-то делать, нужно
   знать подробности устройства подсистемы, порядок инициализации объектов и так далее.

   Классы подсистемы не знают о существовании фасада и работают друг с другом напрямую.
4. `Клиент` использует фасад вместо прямой работы с объектами сложной подсистемы.

## Применимость

**1. Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.**
:::note

Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению меньших
классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные
нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы
по умолчанию, устраивающий большинство клиентов.

:::
**2. Когда вы хотите разложить подсистему на отдельные слои.**
:::note

Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то
зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.

Например, возьмём ту же сложную систему видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для
каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом
через эти фасады, а не напрямую.

:::

## Преимущества и недостатки

:::tip

* Изолирует клиентов от компонентов сложной подсистемы.

:::

:::danger

* Фасад рискует стать божественным объектом, привязанным ко всем классам программы.

:::

## Отношения с другими паттернами
* `Фасад` задаёт новый интерфейс, тогда как `Адаптер` повторно использует старый. `Адаптер` оборачивает только один класс, а `Фасад` оборачивает целую подсистему. Кроме того, `Адаптер` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.
* `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.
* `Легковес` показывает, как создавать много мелких объектов, а `Фасад` показывает, как создать один объект, который отображает целую подсистему.
* `Посредник` и `Фасад` похожи тем, что пытаются организовать работу множества существующих классов.\

   * `Фасад` создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании `Фасада`. Классы подсистемы общаются друг с другом напрямую.
   * `Посредник` централизует общение между компонентами системы. Компоненты системы знают только о существовании `Посредника`, у них нет прямого доступа к другим компонентам.
* `Фасад` можно сделать `Одиночкой`, так как обычно нужен только один объект-фасад.
* `Фасад` похож на `Заместитель` тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от `Фасада`, `Заместитель` имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.

## Пример

```ts
/**
 * Паттерн Фасад
 *
 * Назначение: Предоставляет простой интерфейс к сложной системе классов,
 * библиотеке или фреймворку.
 */

/**
 * Класс Фасада предоставляет простой интерфейс для сложной логики одной или
 * нескольких подсистем. Фасад делегирует запросы клиентов соответствующим
 * объектам внутри подсистемы. Фасад также отвечает за управление их жизненным
 * циклом. Все это защищает клиента от нежелательной сложности подсистемы.
 */
class Facade {
    protected subsystem1: Subsystem1;

    protected subsystem2: Subsystem2;

    /**
     * В зависимости от потребностей вашего приложения вы можете
     * предоставить Фасаду существующие объекты подсистемы или заставить Фасад
     * создать их самостоятельно.
     */
    constructor(subsystem1?: Subsystem1, subsystem2?: Subsystem2) {
        this.subsystem1 = subsystem1 || new Subsystem1();
        this.subsystem2 = subsystem2 || new Subsystem2();
    }

    /**
     * Методы Фасада удобны для быстрого доступа к сложной функциональности
     * подсистем. Однако клиенты получают только часть возможностей подсистемы.
     */
    public operation(): string {
        let result = 'Facade initializes subsystems:\n';
        result += this.subsystem1.operation1();
        result += this.subsystem2.operation1();
        result += 'Facade orders subsystems to perform the action:\n';
        result += this.subsystem1.operationN();
        result += this.subsystem2.operationZ();

        return result;
    }
}

/**
 * Подсистема может принимать запросы либо от фасада, либо от клиента
 * напрямую. В любом случае, для Подсистемы Фасад – это еще один клиент, и он не
 * является частью Подсистемы.
 */
class Subsystem1 {
    public operation1(): string {
        return 'Subsystem1: Ready!\n';
    }

    // ...

    public operationN(): string {
        return 'Subsystem1: Go!\n';
    }
}

/**
 * Некоторые фасады могут работать с разными подсистемами одновременно.
 */
class Subsystem2 {
    public operation1(): string {
        return 'Subsystem2: Get ready!\n';
    }

    // ...

    public operationZ(): string {
        return 'Subsystem2: Fire!';
    }
}

/**
 * Клиентский код работает со сложными подсистемами через простой интерфейс,
 * предоставляемый Фасадом. Когда фасад управляет жизненным циклом подсистемы,
 * клиент может даже не знать о существовании подсистемы. Такой подход позволяет
 * держать сложность под контролем.
 */
function clientCode(facade: Facade) {
    // ...

    console.log(facade.operation());

    // ...
}

/**
 * В клиентском коде могут быть уже созданы некоторые объекты подсистемы. В
 * этом случае может оказаться целесообразным инициализировать Фасад с этими
 * объектами вместо того, чтобы позволить Фасаду создавать новые экземпляры.
 */
const subsystem1 = new Subsystem1();
const subsystem2 = new Subsystem2();
const facade = new Facade(subsystem1, subsystem2);
clientCode(facade);
```