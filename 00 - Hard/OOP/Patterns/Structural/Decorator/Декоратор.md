`Декоратор` — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую
функциональность, оборачивая их в полезные «обёртки».

## Структура

![img.png](00%20-%20Hard/OOP/Patterns/Structural/Decorator/img.png)

1. `Компонент` задаёт общий интерфейс обёрток и оборачиваемых объектов.
2. `Конкретный компонент` определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом
   изменяют декораторы.
3. `Базовый декоратор` хранит ссылку на вложенный объект-компонент.
   Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои
   операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.
4. `Конкретные декораторы` — это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до
   или после вызова аналогичного поведения обёрнутого объекта.
5. `Клиент` может оборачивать простые компоненты и декораторы в другие декораторы, работая со всеми объектами через общий
   интерфейс компонентов.

## Применимость

**1. Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.**
:::note

Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому
клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

:::
**2. Когда нельзя расширить обязанности объекта с помощью наследования.**
:::note

Во многих языках программирования есть ключевое слово final , которое может заблокировать наследование класса. Расширить
такие классы можно только с помощью Декоратора.

:::

## Преимущества и недостатки

:::tip

* Большая гибкость, чем у наследования.
* Позволяет добавлять обязанности на лету.
* Можно добавлять несколько новых обязанностей сразу.
* Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

:::

:::danger

* Трудно конфигурировать многократно обёрнутые объекты.
* Обилие крошечных классов.

:::

## Отношения с другими паттернами
* `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.
* `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
* `Цепочка обязанностей` и `Декоратор` имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.

   Обработчики в `Цепочке обязанностей` могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны `Декораторы` расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.
* `Компоновщик` и `Декоратор` имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
`Декоратор` оборачивает только один объект, а узел `Компоновщика` может иметь много детей. `Декоратор` добавляет вложенному объекту новую функциональность, а `Компоновщик` не добавляет ничего нового, но «суммирует» результаты всех своих детей.

   Но они могут и сотрудничать: `Компоновщик` может использовать `Декоратор`, чтобы переопределить функции отдельных частей дерева компонентов.
* Архитектура, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
* `Стратегия` меняет поведение объекта «изнутри», а `Декоратор` изменяет его «снаружи».
* `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.

## Пример

```ts
/**
 * Паттерн Декоратор
 *
 * Назначение: Позволяет динамически добавлять объектам новую функциональность,
 * оборачивая их в полезные «обёртки».
 */

/**
 * Базовый интерфейс Компонента определяет поведение, которое изменяется
 * декораторами.
 */
interface Component {
    operation(): string;
}

/**
 * Конкретные Компоненты предоставляют реализации поведения по умолчанию.
 * Может быть несколько вариаций этих классов.
 */
class ConcreteComponent implements Component {
    public operation(): string {
        return 'ConcreteComponent';
    }
}

/**
 * Базовый класс Декоратора следует тому же интерфейсу, что и другие
 * компоненты.   Основная цель этого класса - определить интерфейс обёртки для
 * всех конкретных декораторов. Реализация кода обёртки по умолчанию может
 * включать в себя поле для хранения завёрнутого компонента и средства его
 * инициализации.
 */
class Decorator implements Component {
    protected component: Component;

    constructor(component: Component) {
        this.component = component;
    }

    /**
     * Декоратор делегирует всю работу обёрнутому компоненту.
     */
    public operation(): string {
        return this.component.operation();
    }
}

/**
 * Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
 * некоторым образом.
 */
class ConcreteDecoratorA extends Decorator {
    /**
     * Декораторы могут вызывать родительскую реализацию операции, вместо
     * того, чтобы вызвать обёрнутый объект напрямую. Такой подход упрощает
     * расширение классов декораторов.
     */
    public operation(): string {
        return `ConcreteDecoratorA(${super.operation()})`;
    }
}

/**
 * Декораторы могут выполнять своё поведение до или после вызова обёрнутого
 * объекта.
 */
class ConcreteDecoratorB extends Decorator {
    public operation(): string {
        return `ConcreteDecoratorB(${super.operation()})`;
    }
}

/**
 * Клиентский код работает со всеми объектами, используя интерфейс
 * Компонента. Таким образом, он остаётся независимым от конкретных классов
 * компонентов, с которыми работает.
 */
function clientCode(component: Component) {
    // ...

    console.log(`RESULT: ${component.operation()}`);

    // ...
}

/**
 * Таким образом, клиентский код может поддерживать как простые
 * компоненты...
 */
const simple = new ConcreteComponent();
console.log('Client: I\'ve got a simple component:');
clientCode(simple);
console.log('');

/**
 * ...так и декорированные.
 *
 * Обратите внимание, что декораторы могут обёртывать не только простые
 * компоненты, но и другие декораторы.
 */
const decorator1 = new ConcreteDecoratorA(simple);
const decorator2 = new ConcreteDecoratorB(decorator1);
console.log('Client: Now I\'ve got a decorated component:');
clientCode(decorator2);
```