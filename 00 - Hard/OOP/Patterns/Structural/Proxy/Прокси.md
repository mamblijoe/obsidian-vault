`Заместитель` — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов
специальные объекты-заменители.
Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова
оригиналу.

## Структура

![img.png](00%20-%20Hard/OOP/Patterns/Structural/Proxy/img.png)

1. `Интерфейс сервиса` определяет общий интерфейс для сервиса и заместителя. Благодаря этому, объект заместителя можно
   использовать там, где ожидается объект сервиса.
2. `Сервис` содержит полезную бизнес-логику.
3. `Заместитель` хранит ссылку на объект сервиса. После того как заместитель заканчивает свою работу (например,
   инициализацию, логирование, защиту или другое), он передаёт вызовы вложенному сервису. Заместитель может сам отвечать
   за создание и удаление объекта сервиса.
4. `Клиент` работает с объектами через интерфейс сервиса. Благодаря этому, его можно «одурачить», подменив объект
   сервиса объектом заместителя.

## Применимость

**1. Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы
или базы данных.**
:::note

Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда
он действительно понадобится.

:::
**2. Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект
от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи —
сторонние программы (хорошие или вредоносные).**
:::note

Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

:::
**3. Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.**
:::note

В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

:::
**4. Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.**
:::note

Заместитель может сохранять историю обращения клиента к сервисному объекту.

:::
**5. Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным
циклом.**
:::note

Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными.
Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе
данных).

Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты
повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

:::

## Преимущества и недостатки

:::tip

* Позволяет контролировать сервисный объект незаметно для клиента.
* Может работать, даже если сервисный объект ещё не создан.
* Может контролировать объекта

:::

:::danger

* Усложняет код программы из-за введения дополнительных классов.
* Увеличивает время отклика от сервиса

:::

## Отношения с другими паттернами

* `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный
  интерфейс. `Заместитель` предоставляет тот же интерфейс.
* `Фасад` похож на `Заместитель` тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие
  от `Фасада`, `Заместитель` имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимозаменять.
* `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на
  принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью
  сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.

## Пример

```ts
/**
 * Паттерн Заместитель
 *
 * Назначение: Позволяет подставлять вместо реальных объектов специальные
 * объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту,
 * позволяя сделать что-то до или после передачи вызова оригиналу.
 */

/**
 * Интерфейс Субъекта объявляет общие операции как для Реального Субъекта,
 * так и для Заместителя. Пока клиент работает с Реальным Субъектом, используя
 * этот интерфейс, вы сможете передать ему заместителя вместо реального
 * субъекта.
 */
interface Subject {
    request(): void;
}

/**
 * Реальный Субъект содержит некоторую базовую бизнес-логику. Как правило,
 * Реальные Субъекты способны выполнять некоторую полезную работу, которая к
 * тому же может быть очень медленной или точной – например, коррекция входных
 * данных. Заместитель может решить эти задачи без каких-либо изменений в коде
 * Реального Субъекта.
 */
class RealSubject implements Subject {
    public request(): void {
        console.log('RealSubject: Handling request.');
    }
}

/**
 * Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
 */
class Proxy implements Subject {
    private realSubject: RealSubject;

    /**
     * Заместитель хранит ссылку на объект класса РеальныйСубъект. Клиент
     * может либо лениво загрузить его, либо передать Заместителю.
     */
    constructor(realSubject: RealSubject) {
        this.realSubject = realSubject;
    }

    /**
     * Наиболее распространёнными областями применения паттерна Заместитель
     * являются ленивая загрузка, кэширование, контроль доступа, ведение журнала
     * и т.д. Заместитель может выполнить одну из этих задач, а затем, в
     * зависимости от результата, передать выполнение одноимённому методу в
     * связанном объекте класса Реального Субъект.
     */
    public request(): void {
        if (this.checkAccess()) {
            this.realSubject.request();
            this.logAccess();
        }
    }

    private checkAccess(): boolean {
        // Некоторые реальные проверки должны проходить здесь.
        console.log('Proxy: Checking access prior to firing a real request.');

        return true;
    }

    private logAccess(): void {
        console.log('Proxy: Logging the time of request.');
    }
}

/**
 * Клиентский код должен работать со всеми объектами (как с реальными, так и
 * заместителями) через интерфейс Субъекта, чтобы поддерживать как реальные
 * субъекты, так и заместителей. В реальной жизни, однако, клиенты в основном
 * работают с реальными субъектами напрямую. В этом случае, для более простой
 * реализации паттерна, можно расширить заместителя из класса реального
 * субъекта.
 */
function clientCode(subject: Subject) {
    // ...

    subject.request();

    // ...
}

console.log('Client: Executing the client code with a real subject:');
const realSubject = new RealSubject();
clientCode(realSubject);

console.log('');

console.log('Client: Executing the same client code with a proxy:');
const proxy = new Proxy(realSubject);
clientCode(proxy);
```