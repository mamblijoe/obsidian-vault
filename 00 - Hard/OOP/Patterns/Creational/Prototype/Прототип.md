`Прототип` — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их
реализации.

## Структура

![img.png](00%20-%20Hard/OOP/Patterns/Creational/Prototype/img.png)

1. `Интерфейс прототипов` описывает операции клонирования.

   В большинстве случаев — это единственный метод clone .

2. `Конкретный прототип` реализует операцию клонирования самого себя.

   Помимо банального копирования значений всех полей, здесь могут быть спрятаны различные сложности, о которых не нужно
   знать клиенту. Например, клонирование связанных объектов, распутывание рекурсивных зависимостей и прочее.
3. `Клиент` создаёт копию объекта, обращаясь к нему через общий интерфейс прототипов.

## Применимость

**1. Когда ваш код не должен зависеть от классов копируемых объектов.**
>[!tip] Решение
>Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете
привязаться к их классам, даже если бы хотели, поскольку их конкретные классы неизвестны.
>
Паттерн прототип предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту не нужно зависеть от
всех классов копируемых объектов, а только от интерфейса клонирования.

**2. Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы,
чтобы иметь возможность легко порождать объекты с определённой конфигурацией.**
>[!tip] Решение
>Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных
конфигураций объектов.
>
Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых
уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её
сложность.
## Преимущества и недостатки

>[!tip] Преимущества
>* Позволяет клонировать объекты, не привязываясь к их конкретным классам.
>* Меньше повторяющегося кода инициализации объектов.
>* Ускоряет создание объектов.
>* Альтернатива созданию подклассов для конструирования сложных объектов.

>[!danger] Недостатки
>* Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
## Отношения с другими паттернами

* Многие архитектуры начинаются с применения [[Фабричный метод|Фабричного метода]] (более простого и расширяемого через подклассы) и эволюционируют в сторону [[Абстрактная фабрика|Абстрактной фабрики]], `Прототипа` или [[Строитель|Строителя]] (более гибких, но и более сложных).
* Классы [[Абстрактная фабрика|Абстрактной фабрикм]] чаще всего реализуются с помощью  [[Фабричный метод|Фабричного метода]], хотя они могут быть построены и на основе `Прототипа`.
* Если [[Команда|Команду]] нужно копировать перед вставкой в историю выполненных команд, вам может помочь `Прототип`.
* Архитектура, построенная на [[Композит|Композитах]] и [[Декоратор|Декораторах]], часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
* `Прототип` не опирается на наследование, но ему нужна сложная операция
  инициализации. [[Фабричный метод]], наоборот, построен на наследовании, но не требует сложной инициализации.
* [[Мементо]] иногда можно заменить `Прототипом`, если объект, состояние которого требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.
* [[Абстрактная фабрика]], [[Строитель]] и `Прототип` могут быть реализованы при
  помощи [[Синглтон|Синглтона]].

## Пример

```ts
/**
 * Паттерн Прототип
 *
 * Назначение: Позволяет копировать объекты, не вдаваясь в подробности их
 * реализации.
 */

/**
 * Пример класса, имеющего возможность клонирования. Мы посмотрим как
 * происходит клонирование значений полей разных типов.
 */
class Prototype {
    public primitive: any;
    public component: object;
    public circularReference: ComponentWithBackReference;

    public clone(): this {
        const clone = Object.create(this);

        clone.component = Object.create(this.component);

        // Клонирование объекта, который имеет вложенный объект с обратной
        // ссылкой, требует специального подхода. После завершения клонирования
        // вложенный объект должен указывать на клонированный объект, а не на
        // исходный объект. Для данного случая хорошо подойдёт оператор
        // расширения (spread).
        clone.circularReference = {
            ...this.circularReference,
            prototype: {...this},
        };

        return clone;
    }
}

class ComponentWithBackReference {
    public prototype;

    constructor(prototype: Prototype) {
        this.prototype = prototype;
    }
}

/**
 * Клиентский код.
 */
function clientCode() {
    const p1 = new Prototype();
    p1.primitive = 245;
    p1.component = new Date();
    p1.circularReference = new ComponentWithBackReference(p1);

    const p2 = p1.clone();
    if (p1.primitive === p2.primitive) {
        console.log('Primitive field values have been carried over to a clone. Yay!');
    } else {
        console.log('Primitive field values have not been copied. Booo!');
    }
    if (p1.component === p2.component) {
        console.log('Simple component has not been cloned. Booo!');
    } else {
        console.log('Simple component has been cloned. Yay!');
    }

    if (p1.circularReference === p2.circularReference) {
        console.log('Component with back reference has not been cloned. Booo!');
    } else {
        console.log('Component with back reference has been cloned. Yay!');
    }

    if (p1.circularReference.prototype === p2.circularReference.prototype) {
        console.log('Component with back reference is linked to original object. Booo!');
    } else {
        console.log('Component with back reference is linked to the clone. Yay!');
    }
}

clientCode();
```