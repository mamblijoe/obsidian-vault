`Фабричный метод` — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в
суперклассе, позволяя подклассам изменять тип создаваемых объектов.

## Структура
![img.png](00%20-%20Hard/OOP/Patterns/Creational/Factory-method/img.png)

1. `Продукт` определяет общий интерфейс объектов, которые может произвести создатель и его подклассы.
2. `Конкретные продукты` содержат код различных продуктов.
   Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. `Создатель` объявляет фабричный метод, который должен возвращать новые объекты продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом продуктов.

   Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. Но он может возвращать и некий стандартный продукт.

   Несмотря на название, важно понимать, что создание продуктов **не является** единственной функцией создателя. Обычно он содержит и другой полезный код работы с продуктом.
4. `Конкретные создатели` по-своему реализуют фабричный метод, производя те или иные конкретные продукты.

   Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.

## Применимость

**1. Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.**

>[!tip] Решение
Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.
>
Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта,
вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

**2. Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.**

**3. Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.**
## Преимущества и недостатки

>[!tip]  Преимущества
>
>* Избавляет класс от привязки к конкретным классам продуктов.
>* Выделяет код производства продуктов в одно место, упрощая поддержку кода.
>* Упрощает добавление новых продуктов в программу.
>* Реализует принцип открытости/закрытости.

>[!danger] Недостатки
>* Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой
  подкласс создателя.
## Отношения с другими паттернами

* Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону [[Абстрактная фабрика|Абстрактной фабрики]], [[Прототип|Прототипа]] или [[Строитель|Строителя]] (более гибких, но и более сложных).
* Классы [[Абстрактная фабрика|Абстрактной фабрики]] чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе [[Прототип|Прототипа]].
* `Фабричный метод` можно использовать вместе с [[Итератор|Итератором]], чтобы подклассы коллекций могли создавать подходящие им итераторы.
* [[Прототип]] не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот, построен на наследовании, но не требует сложной инициализации.
* `Фабричный метод` можно рассматривать как частный случай [[Шаблонный метод|Шаблонного метода]]. Кроме того, `Фабричный метод` нередко бывает частью большого класса с [[Шаблонный метод|Шаблонным методом]].

## Пример

```ts
/**
 * Паттерн Фабричный Метод
 *
 * Назначение: Определяет общий интерфейс для создания объектов в суперклассе,
 * позволяя подклассам изменять тип создаваемых объектов.
 */

/**
 * Класс Создатель объявляет фабричный метод, который должен возвращать
 * объект класса Продукт. Подклассы Создателя обычно предоставляют реализацию
 * этого метода.
 */
abstract class Creator {
    /**
     * Обратите внимание, что Создатель может также обеспечить реализацию
     * фабричного метода по умолчанию.
     */
    public abstract factoryMethod(): Product;

    /**
     * Также заметьте, что, несмотря на название, основная обязанность
     * Создателя не заключается в создании продуктов. Обычно он содержит
     * некоторую базовую бизнес-логику, которая основана на объектах Продуктов,
     * возвращаемых фабричным методом. Подклассы могут косвенно изменять эту
     * бизнес-логику, переопределяя фабричный метод и возвращая из него другой
     * тип продукта.
     */
    public someOperation(): string {
        // Вызываем фабричный метод, чтобы получить объект-продукт.
        const product = this.factoryMethod();
        // Далее, работаем с этим продуктом.
        return `Creator: The same creator's code has just worked with ${product.operation()}`;
    }
}

/**
 * Конкретные Создатели переопределяют фабричный метод для того, чтобы
 * изменить тип результирующего продукта.
 */
class ConcreteCreator1 extends Creator {
    /**
     * Обратите внимание, что сигнатура метода по-прежнему использует тип
     * абстрактного продукта, хотя фактически из метода возвращается конкретный
     * продукт. Таким образом, Создатель может оставаться независимым от
     * конкретных классов продуктов.
     */
    public factoryMethod(): Product {
        return new ConcreteProduct1();
    }
}

class ConcreteCreator2 extends Creator {
    public factoryMethod(): Product {
        return new ConcreteProduct2();
    }
}

/**
 * Интерфейс Продукта объявляет операции, которые должны выполнять все
 * конкретные продукты.
 */
interface Product {
    operation(): string;
}

/**
 * Конкретные Продукты предоставляют различные реализации интерфейса
 * Продукта.
 */
class ConcreteProduct1 implements Product {
    public operation(): string {
        return '{Result of the ConcreteProduct1}';
    }
}

class ConcreteProduct2 implements Product {
    public operation(): string {
        return '{Result of the ConcreteProduct2}';
    }
}

/**
 * Клиентский код работает с экземпляром конкретного создателя, хотя и через
 * его базовый интерфейс. Пока клиент продолжает работать с создателем через
 * базовый интерфейс, вы можете передать ему любой подкласс создателя.
 */
function clientCode(creator: Creator) {
    console.log('Client: I\'m not aware of the creator\'s class, but it still works.');
    console.log(creator.someOperation());
}

/**
 * Приложение выбирает тип создателя в зависимости от конфигурации или
 * среды.
 */
console.log('App: Launched with the ConcreteCreator1.');
clientCode(new ConcreteCreator1());
console.log('');

console.log('App: Launched with the ConcreteCreator2.');
clientCode(new ConcreteCreator2());
```