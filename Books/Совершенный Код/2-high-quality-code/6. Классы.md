## АТД
`Абстрактный тип данных` - это набор, включающий данные и выполняемые над ними операции.

>[!tip] Преимущества использования АТД
>* Возможность сокрытия деталей реализации
>* Ограничение области изменений
>* Более высокая информативность интерфейса
>* Легкость оптимизации кода
>* Легкость проверки кода
>* Удобочитаемость и понятность кода
>* Ограничение области использования данных
>* Возможность работы с сущностями реального мира, а не с низкоуровневыми деталями реализации

## Принципы использования АТД

>[!info] Представляйте в форме АТД распространенные низкоуровневые типы данных
>Например, работать с списком сотрудников как с массивом

>[!info] Представляйте в форме АТД часто используемые объекты, такие как файлы

>[!info] Представляйте в форме АТД даже простые элементы
>Например сущность всего с 2 методами

>[!info] Обращайтес к АТД так, что бы это не зависело от среды, используемой для хранения
>Не учитывать особенности ОС или формы хранения, например, не указывать в название АТД что что-то хранится как файл, далее, АТД может храниться уже не как файл

## Качественные интерфейсы классов

### Хорошая абстракция

>[!info] Выражайте в интерфейсе класса согласованный уровень абстракции
>Например, класс нарушает принцип единой ответственности или сущность наследуется от не "своего" класса (список сотрудников наследуется от List для получения методов перебора, например)

>[!info] Убедитесь что понимаете, реализацией какой абстракции является класс

>[!info] Предоставляйте методы вместе с противоположными им методами
>Например, `openModal()` и `closeModal()`

>[!info] Убирайте постороннюю информацию в другие классы
>Например, нарушение принципа единой ответственности или если какие то методы работают только с одной половиной данных

>[!info] Делайте интерфейсы программными, а не семантическими
>Семантический - это предположения об использовании интерфейса, например, Метода А должен быть вызван перед Методом Б или Метод А вызовет ошибку если переданный аргументом элемент данных не подготовлен

>[!info] Опасайтесь нарушения целостности интерфейса при изменении класса
>При расширении и изменении класса может добавлять доп функциональность которая не соответствует первоначальному интерфейсу класса

>[!info] Не добавляйте публичные свойства которые не согласуются с абстракцией интерфейса

>[!info] Рассматривайте абстракцию и связность вместе
>Оба понятия тесно связаны. Обычно если интерфейс класса предоставляет хорошую абстракцию то класс отличается высокой связностью `(high cohesion)`

### Хорошая инкапсуляция 

>[!info] Минимизируйте публичные методы и свойства

>[!info] Не делайте предположений о клиентах класса

>[!info] Цените легкость чтения кода выше, чем удобство написания

>[!info] Очень, очень настороженно относитесь к семантическим нарушениям инкапсуляции
>Примеры нарушения семантической инкапсуляции:
>* Решить не вызывать `init()` класса А, потому что другой метода класса А вызывает его автоматически
>* Не вызывать `connect()`, потому что знаете что метод `select()` установит соединение если его нет
>* Не вызывать метод `destruct()` потому что другой метод уже вызвал его
>Проблема в зависимости клиентского кода от закрытой реализации класса, а не от открытой его части

>[!info] Остерегайтесь слишком высокого сопряжения `(high coupling)`
>* Меньше публичных методов и свойств
>* Лучше private, вместо protected
>* Не оставлять публичными свойства, а делать геттеры и сеттеры
>* Соблюдать [[Закон Деметры]]

## Разумные причины создания классов

>[!info] Моделирование объектов реального мира

>[!info] Моделирование абстрактных объектов 
>Например, классы фигур

>[!info] Снижение сложности
>Можно не думать о реализации в классе пока работаешь с другой частью системы


>[!info] Изоляция сложности
>Сложность изолированна в отдельном классе

>[!info] Сокрытие деталей реализации

>[!info] Ограничение влияния изменений

>[!info] Сокрытие глобальных данных
>Можно скрывать детали реализации глобальных данных в классе

>[!info] Упрощение передачи параметров в методы
>Например, часто используемый аргумент передается в конструкторе и в методе используется через `this`

>[!info] Создание центральных точек управления

>[!info] Облегчение повторного использования кода

>[!info] Планирование создания семейств

>[!info] Упаковка родственных операций / команд

>[!info] Выполнение специфического вида рефакторинга

## Классы которые следует избегать

>[!danger] God object

>[!danger] Нерелевантные классы
>Класс имеет только свойства, без методов. Возможно тут будет уместнее просто объект

>[!danger] Классы с именами глаголами

>[!tip] Ключевые моменты
>* Интерфейс класса должен формировать согласованную абстракцию. Многие проблемы объясняются нарушением одного этого
 принципа.
>* Интерфейс класса должен что-то скрывать — особенности взаимодействия с системой, аспекты проектирования или детали
 реализации.
>* Включение обычно предпочтительнее, чем наследование, если только вы не моделируете отношение «является».
>* Наследование — полезный инструмент, но оно повышает сложность, что противоречит Главному Техническому Императиву
 Разработки ПО, которым является управление сложностью.
>* Классы — главное средство управления сложностью. Уделите их проектированию столько времени, сколько нужно для
 достижения этой цели.