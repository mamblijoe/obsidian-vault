>[!info] Сопряжение при котором модули имеют семантические знания о внутренней работе сопряженного модуля  
Пример:
>- В модуль передается какой то флаг определяющий алгоритм работы модуля
>- Модуль использует глобальные данные и предполагает вызов в определенное время когда эти данные были изменены
>- Методы модуля предполагают что вызываются после определенных методов (например, методы типа init())
>- Модули передают частично инициализируемые объекты

>[!info]  В модуль передается какой то флаг определяющий алгоритм работы модуля
```ts
class Module {
  public run(flag: boolean) {
    if (flag) {
      this.runActionA();
    } else {
      this.runActionB();
    }
  }

  private runActionA() {}
  
  private runActionB() {}
}
```

>[!info] Модуль использует глобальные данные и предполагает вызов в определенное время когда эти данные были изменены
```ts
type User = {
  id: number;
  name: string;
  email: string;
};

type Store = {
  user: User;
};

const GLOBAL_STORE: Store = {
  user: { id: 1, name: "John Doe", email: "john.doe@gmail.com" },
};

class ModuleA {
  public updateUser(partialUser: Partial<User>) {
    GLOBAL_STORE.user = { ...GLOBAL_STORE.user, ...partialUser };
  }
}

class ModuleB {
  public printUserInfo() {
    console.log(`Id: ${GLOBAL_STORE.user.id}`);
    console.log(`Name: ${GLOBAL_STORE.user.name}`);
    console.log(`Email: ${GLOBAL_STORE.user.email}`);
  }
}

const a = new ModuleA();
const b = new ModuleB();

a.updateUser({ id: 2, name: "John Black Doe" });
b.printUserInfo();
```

>[!info] Методы модуля предполагают что вызываются после определенных методов (например, методы типа init())
```ts
class ModuleA {
  private isInited: boolean = false;
  
  public init() {
    this.isInited = true;
  }

  public run() {
    if (!this.isInited) {
      throw new Error("Error");
    }
  }
}

class ModuleB {
  private root: ModuleA;

  constructor(root: ModuleA) {
    this.root = root;
  }

  run() {
    this.root.run();
  }

}

const a = new ModuleA();
const b = new ModuleB(a);

b.run();

