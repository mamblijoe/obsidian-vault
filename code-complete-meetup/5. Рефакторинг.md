Важнейшей стратегией достижения цели Главного Правила Эволюции ПО является рефакторинг, который Мартин Фаулер определяет как «изменение внутрен# ней структуры ПО без изменения его наблюдаемого поведения, призванное облегчить его понимание и удешевить модификацию» (Fowler, 1999). Слово «рефакоринг» возникло из слова «факторинг», которое изначально использовал в контексте структурного программирования Ларри Константайн, назвавший так максимально возможную декомпозицию программы на составляющие части (Yourdon and Constantine, 1979)

Эволюция ПО похожа на биологическую эволюцию тем, что лишь немногие мутации выгодны. При здоровой эволюции кода его развитие напоминает превращение обезьян в неандертальцев, а неандертальцев — в программистов, которые, как известно, являются самыми высокоразвитыми существами на Земле. Однако иногда эволюционные силы проявляют себя иным образом, ввергая программу в спираль деградации.

Главное различие между видами эволюции программы в том, повышается или снижается ее качество в результате изменений. Если при исправлении ошибок вы опираетесь на суеверия и устраняете лишь симптомы проблем, качество снижается. Если же вы рассматриваете изменения как возможности улучшить первоначальный проект программы, — повышается. При снижении качества программа начинает походить на молчащую канарейку в шахте, о которой я уже говорил. Это знак того, что программа развивается в неверном направлении.

Характер эволюции программы зависит и от того, когда в нее вносятся изменения: во время конструирования или во время сопровождения. Изменения во время конструирования обычно вносят первоначальные разработчики, которые еще хорошо помнят код программы. Система еще не используется, поэтому программисты испытывают давление только со стороны графика разработки, а не сотен сердитых пользователей, возмущенных неработоспособностью системы. По той же причине изменения во время конструирования можно вносить более свободно: система находится в более динамичном состоянии, а следствия ошибок менее серьезны. Из этого следует, что во время разработки ПО эволюционирует не так, как при сопровождении

### Философия эволюции ПО

Слабость многих подходов к эволюции ПО объясняется тем, что она пускается на самотек. Осознав, что эволюция ПО во время его разработки — неизбежный и важный процесс и спланировав его, вы сможете извлечь из него выгоду

Эволюция заключает в себе и опасность, и возможность приближения к совершенству. При необходимости изменения кода старайтесь улучшить его, чтобы облегчить внесение изменений в будущем. В процессе написания программы вы всегда узнаете о ней что-то новое. Получив возможность изменения программы, используйте то, что вы узнали, для ее улучшения. Пишите первоначальный код и его изменяйте, держа в уме дальнейшие изменения.

Главное Правило Эволюции ПО состоит в том, что эволюция должна повышать внутреннее качество программы. О том, как этого добиться, я расскажу в следующих разделах.

>[!success] Разумные причины выполнения рефакторинга
>* Код повторяется
>* Метод слишком велик
>* Цикл слишком велик или имеет глубокую вложенность
>* Класс имеет плохую связность
>* Интерфейс класса не формирует согласованную абстракцию
>* Метод принимает слишком много параметров
>* Отдельные части класса меняет независимо от других частей
>* При изменении программы приходится параллельно менять несколько классов
>* Приходится менять параллельно несколько иерархий наследования
>* Приходится менять параллельно несколько блоков `case`
>* Родственные элементы данных, используемые вместе, не организован в классы
>* Метод использует больше параметра чужого класса, чем своего
>* Элементарный тип данных перегружен
>* Класс имеет слишком ограниченную функциональность
>* По цепи методов передаются бродячие данные
>* Прокси-объект ничего не делает
>* Один класс слишком много знает о другом
>* Метод имеет не удачное имя
>* Лишние публичные методы и свойства
>* Подкласс использует мало методов или свойств от наследования
>* Сложный код объясняется с помощью комментариев
>* Код содержит глобальные переменные
>* Перед вызовом метода выполняется подготовительный код
>* Программа содержит код который когда-нибудь может понадобиться

>[!danger] Плохие причины рефакторинга
>* Не рассматривайте рефакторинг как оправдание написание плохого кода с намерением исправить его позднее
>* Не рассматривайте рефакторинг как способ избежать переписывание кода

## Безопасный рефакторинг

* Сохраняйте первоначальный код
* Ограничивайте объем отдельных видов рефакторинга
* Выполняйте отдельные виды рефакторинга по одному за раз
* Составьте список действий которые хотите предпринять
* Составьте список видов рефакторинга которые следует выполнить позже
* Часто создавайте контрольные точки
* Выполняйте регрессивное-тестирование
* Создавайте дополнительные тесты
* Выполняйте обзоры измненеий
* Изменяйте подход в зависимости от рискованности рефакторинга

## Стратегии рефакторинга

* Выполняйте рефакторинг при создании новых методов
* Выполняйте рефакторинг при создании новых классов
* Выполняйте рефакторинг при исправлении дефектов
* Выполняйте рефакторинг модулей подтверженных ошибках
* Выполняйте рефакторинг сложных модулей

>[!tip] Ключевые моменты
>* Изменения программы неизбежны как во время первоначальной разработки, так и после выпуска первой версии.
>* Изменения могут приводить как к улучшению, так и к ухудшению ПО. Главное Правило Эволюции ПО заключается в том, что при эволюции кода внутреннее качество программы должно повышаться.
>* Одним из условий успешности рефакторинга является пристальное внимание к многочисленным предупреждающим знакам —  «запахам», указывающим на необходимость рефакторинга.
>* Другое условие — изучение многих конкретных видов рефакторинга.
>* Заключительным условием успешности рефакторинга является следование стратегии безопасного рефакторинга. Одни подходы к  рефакторингу лучше, а другие хуже.
>* Рефакторинг во время разработки — самая благоприятная возможность улучшения программы и внесения в нее всех изменений, которые вам так или иначе захочется внести позднее. Используйте эту возможность!
