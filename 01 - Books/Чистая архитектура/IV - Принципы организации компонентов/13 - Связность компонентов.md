---
creation date: 2024-11-03 21:59
modification date: воскресенье 3-го ноября 2024 21:59:21
tags: 
---
## Принцип эквивалентности повторного использования и выпусков
 
>[!example] Единица повторного использования есть единица выпуска

>[!success] Классы и модули, объединяемые в компонент, должны выпускаться вместе.
>С точки зрения архитектуры и дизайна этот принцип означает, что классы и модули, составляющие компонент, должны принадлежать связной группе. Компонент не может просто включать случайную смесь классов и модулей; должна быть какая-то тема или цель, общая для всех модулей

>[!example] Принцип эквивалентности повторного использования и выпусков (Release/Reuse Equivalency Principle, REP). 
>
>Этот принцип говорит о том, что единицы повторного использования (модули, пакеты, библиотеки) должны собираться и публиковаться как единое целое. То есть, если вы хотите повторно использовать какую-то часть системы, она должна быть частью публичного выпуска и поддерживаться как единое целое.

```ts
src/
├── utils/
│   ├── ArrayUtils.ts
│   ├── StringUtils.ts
├── models/
│   ├── User.ts
│   └── Product.ts
├── services/
│   ├── UserService.ts
│   └── ProductService.ts
index.ts
```

**`utils/ArrayUtils.ts`**
```ts
export function unique<T>(array: T[]): T[] {
    return Array.from(new Set(array));
}

export function flatten<T>(array: T[][]): T[] {
    return array.reduce((acc, val) => acc.concat(val), []);
}
```

**`utils/StringUtils.ts`**
```ts
export function capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

export function camelCase(str: string): string {
    return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}
```

**`models/User.ts`**
```ts
export interface User {
    id: number;
    name: string;
    email: string;
}

export function createUser(name: string, email: string): User {
    return { id: Date.now(), name, email };
}
```

Чтобы следовать принципу RREP, нам нужно объединить все эти модули в один пакет и опубликовать его как библиотеку.

**`index.ts`**
```ts
export * from './utils/ArrayUtils';
export * from './utils/StringUtils';
export * from './models/User';
```

`package.json`
```json
{
  "name": "my-typescript-library",
  "version": "1.0.0",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "npm run build"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```
---
## Принцип согласованного изменения
>[!example] В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время.
>
>Так же, как принцип `SRP`, гласящий, что класс не должен иметь несколько причин для изменения, принцип согласованного изменения (`CCP`) требует, что бы компонент не имел нескольких причин для изменения.
>
>Принцип `CCP` требует от нас собирать вместе все классы, которые может понадобиться изменить по одной, общей причине. Если два класса тесно связанны, физически или концептуально, настолько что всегда будут изменяться вместе, они должны принадлежать одному компоненту.

`Исходный код (до применения CCP)`
```ts
src/
├── services/
│   ├── OrderService.ts
│   └── NotificationService.ts
├── models/
│   └── Order.ts
index.ts
```

>[!danger] Проблема
>
>- **OrderService** и **NotificationService** относятся к одной и той же бизнес-логике (управление заказами).
>- Если изменяется логика обработки заказов (например, добавляется новый статус), нам приходится вносить изменения в оба файла.
>- Это нарушает принцип **согласованного изменения**.

`Структура проекта (после применения CCP)`
```ts
src/
├── modules/
│   └── OrderModule.ts
index.ts
```

>[!success] Решение
>
Мы объединим **OrderService** и **NotificationService** в один модуль, так как изменения в логике обработки заказов обычно требуют изменений и в уведомлениях.

>[!tip] Объяснение
>
Теперь мы объединили **OrderService** и **NotificationService** в один модуль. Если бизнес-логика обработки заказов изменится, нам нужно будет изменить только один файл. Это соответствует принципу согласованного изменения.
>
> ## Преимущества
>
>1. **Меньше изменений**: При изменении бизнес-логики изменения нужно вносить только в один модуль.
>2. **Лучшая поддержка**: Меньше риска нарушить работу при модификациях.
>3. **Инкапсуляция**: Логически связанные классы теперь находятся вместе, что делает код более понятным.

---
## Принцип совместного повторного использования
>[!example] Не вынуждайте пользователей компонента зависеть от того, чего им не требуется.

>[!example] Не создавайте зависимостей от чего-либо неиспользуемого.

`Структура проекта (до применения CRP)`
```ts
src/
├── services/
│   ├── ProductService.ts
│   ├── CartService.ts
│   └── UserService.ts
index.ts
```

>[!danger] Проблема
>- Если мы хотим использовать **ProductService** и **CartService** совместно в других проектах, нам нужно импортировать их по отдельности.
>- Эти модули тесно связаны (корзина использует продукты), и при изменении логики в одном из них может потребоваться изменение другого.
>- Это нарушает принцип **совместного повторного использования**, так как при использовании одного из модулей нам часто нужно подтягивать и другой.

>[!success] Решение
Мы объединим **ProductService** и **CartService** в один модуль, так как они используются вместе.

`Структура проекта (после применения CRP)`
```ts
src/
├── modules/
│   └── ShopModule.ts
index.ts
```

>[!tip] Объяснение
>
Теперь мы объединили **ProductService** и **CartService** в один модуль **ShopModule**. Это сделано потому, что они обычно используются совместно, и изменения в одном из них могут повлиять на другой.
>
> Преимущества
>
>1. **Снижение избыточных зависимостей**: Если вам нужен функционал работы с продуктами и корзиной, вы импортируете только один модуль.
>2. **Упрощение поддержки**: Если требуется изменение логики работы с продуктами и корзиной, это можно сделать в одном месте.
>3. **Инкапсуляция**: Связанные классы и сервисы объединены в один модуль, что упрощает повторное использование.
>
Теперь, при необходимости повторного использования модуля **ShopModule**, нам не нужно тянуть за собой избыточные зависимости — всё, что используется совместно, находится в одном месте.

