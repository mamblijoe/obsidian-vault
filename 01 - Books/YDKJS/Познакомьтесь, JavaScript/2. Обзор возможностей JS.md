>[!tip] В JS значения существуют в 2 формах: примитивы и объекты

## Определение типа значения

```js
typeof undefined;        //undefined
typeof null;             //object
typeof function hello(); //function
typeof [1,2,3];          //object
```


>[!danger] К сожалению, `typeof null` возвращает `object` вместо ожидаемого `null`. Также `typeof` возвращает `function` для функций, но не возвращает `array` для массивов

## Объявление и использование переменных

### Различные синтаксические формы объявления переменных

* `var`, `let`, `const`
* `catch(error) {}`
* `function hello () {}`

## Функции

### Function declaration

```js
function hello() {}
```

>[!tip] Связь между идентификатором `hello` и значением-функцией устанавливается в фазе компиляции кода, до его выполнения. Из за этого `function declaration` всплывают и их можно использовать до места объявления в коде

### Function expression

```js
const hello = function () {}
```

>[!tip] Связь между идентификатором `hello` и значением-функцией не устанавливается до момента выполнения команды на стадии выполнения. Из за этого `function expression` не всплывают и их нельзя использовать до места объявления в коде

### Сравнения

>[!tip] `==` и `===` работают одинаково, но `===` запрещает преобразования типа
>`==` и `===` учитывают тип сравниваемых значений. И если сравниваются значения одинаковых типов то они работаю абсолютно одинаково. 
>Если сравниваются значения разных типов, то `==` от `===` тем, что он допускает преобразования типа перед сравнением.
>Оба оператора стараются сравнить значения похожих типов, но `==` позволяет сначала выполнить преобразования тип, и после того как после преобразования остаются значения одинаковых типов то `==` делает тоже самое что и `===`

>[!danger] Оператор `===` сознательно проектировался так, что бы возвращал ложную информацию для двух специальных значений: `Nan` и `-0`
>```js
>NaN === NaN; //false  -> Альтернатива `Number.isNaN()`
>0 === -0;    //true   -> Альтернатива `Object.is()`
>```

>[!tip] JS не определяет `===` как структурное равенство для объектных значений. Вместо этого `===` использует тождественное равенство, т.е. проверяет тождественность ссылок.